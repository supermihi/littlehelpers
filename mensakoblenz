#!/usr/bin/python3
# coding: UTF-8
# Copyright: 2013 Michael Helmling
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3 as
# published by the Free Software Foundation
#
# mensakoblenz - Skript zur Textausgabe des aktuellen Tagesmenüs in der
# Mensa der Uni Koblenz.


from collections import OrderedDict
import datetime, re, sys
from lxml import html

url = "http://www.studierendenwerk-koblenz.de/go/uni-campus-koblenz/essen/speiseplan"


def getWeekTable(week):
    """Tabelle der angegebenen Woche als Liste von OrderedDicts parsen.
    
    Gibt eine Liste zurück, die den numerischen Wochentag (0 = Montag) auf ein geordnetes
    Dictionary abbildet. In letzterem wird die Art des Menüs ("Abendmensa", "Menü 1", etc.)
    auf das Menü des entsprechenden Wochentags abgebildet.
    """
    ret = [OrderedDict() for i in range(5)]
    table = html.parse(url).getroot().find_class("kw-{:02d}".format(week))[0]
    body = table.find("tbody")
    head = table.find("thead")
    for row, dct in zip(body.findall("tr"), ret):
        for data in row.findall("td"):
            headerId = data.get("headers").split(" ", 1)[1]
            if "geschlossen" in data.text.lower():
                continue
            dct[head.get_element_by_id(headerId).text] = \
                    data.text.replace("\r\n", "").replace(":-)", "").strip()
    return ret


def getMenu(filters=None, offset=0):
    """Das heutige Menü; falls *filter* gesetzt ist, nur Menüs der entsprechenden Art.
    
    Gefiltert werden alle Menüarten die den Filter enthalten.
    """
    date = datetime.date.today() + datetime.timedelta(days=offset)
    week, day = date.isocalendar()[1], date.weekday()
    table = getWeekTable(week)
    tableToday = table[day]
    if filters is not None and len(filters) > 0:
        filters = [f.lower() for f in filters]
        menu = OrderedDict()
        for kind, dish in tableToday.items():
            if not any(f in kind.lower() for f in filters):
                continue
            menu[kind] = dish
    else:
        menu = OrderedDict(tableToday)
    return menu


if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description="Mensa-Menü der Uni Koblenz anzeigen")
    parser.add_argument("-s", "--short", action="store_true", help="Ausgabe in Kurzform")
    parser.add_argument("-m", "--maindish", action="store_true",
                        help="Nur Hauptgericht (ohne Suppe, Salat, Dessert) anzeigen")
    parser.add_argument("offset", nargs="?", metavar="+/-n",
                        help="Tag ändern, z.B. '+7' (in einer Woche), '-1' (gestern)")
    parser.add_argument("filter", nargs="*", help="Filter für Menü-Art (z.B. 'veg', '1', …)")
    args = parser.parse_args()
    posargs = args.filter
    if args.offset:
        posargs += [args.offset]
    offset = 0
    for i, arg in enumerate(posargs):
        if arg[0] in "+-":
            offset = int(arg)
            del posargs[i]
            break
    try:
        menu = getMenu(filters=posargs, offset=offset)
    except IndexError:
        print("Kein Menü gefunden. Ist schon Wochenende?")
        sys.exit(1)
    if args.maindish:
        for key, value in menu.items():
            words = re.split("[\W,]+", value)
            if "uppe" in words[0]:
                del words[0]
            while words[-1] in ("Dessert", "Salat", "mit", "und", "dazu"):
                del words[-1]
            menu[key] = " ".join(words).strip("., ")
    if not args.short:
        maxNameLength = max(len(kind) for kind in menu)
        for kind, dish in menu.items():
            print(('{:' + str(maxNameLength+1) + 's}: {}').format(kind, dish))
    else:
        print(" • ".join(menu.values()))
