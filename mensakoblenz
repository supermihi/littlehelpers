#!/usr/bin/python3
# coding: UTF-8
# Copyright: 2013 Michael Helmling
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3 as
# published by the Free Software Foundation
#
# mensakoblenz - Skript zur Textausgabe des aktuellen Tagesmenüs in der
# Mensa der Uni Koblenz.
 

from collections import OrderedDict
import datetime
import re
import sys
from lxml import html

url = "http://www.studierendenwerk-koblenz.de/go/uni-campus-koblenz/essen/speiseplan"


def getWeekTable(week):
    """Tabelle der angegebenen Woche als Liste von OrderedDicts parsen.
    
    Gibt eine Liste zurück, die den numerischen Wochentag (0 = Montag) auf ein geordnetes
    Dictionary abbildet. In letzterem wird die Art des Menüs ("Abendmensa", "Menü 1", etc.)
    auf das Menü des entsprechenden Wochentags abgebildet.
    """
    ret = [OrderedDict() for i in range(5)]
    table = html.parse(url).getroot().find_class("kw-{:02d}".format(week))[0]
    body = table.find("tbody")
    head = table.find("thead")
    for row, dct in zip(body.findall("tr"), ret):
        for data in row.findall("td"):
            headerId = data.get("headers").split(" ", 1)[1]
            dct[head.get_element_by_id(headerId).text] = data.text.replace("\r\n", "").replace(":-)", "").strip()
    return ret

        
def currentWeekAndDay():
    """Gibt die aktuelle Kalenderwoche und den Wochentag als Tupel zurück"""
    today = datetime.date.today()
    return today.isocalendar()[1], today.weekday()


def getMenu(filters=None, offset=0):
    """Das heutige Menü; falls *filter* gesetzt ist, nur Menüs der entsprechenden Art.
    
    Gefiltert werden alle Menüarten die den Filter enthalten.
    Beispiele: "veg", "abend", "1", "extra".
    """
    week, day = currentWeekAndDay()
    day += offset
    table = getWeekTable(week)
    tableToday = table[day]
    if filters is not None and len(filters) > 0:
        filters = [f.lower() for f in filters]
        menu = OrderedDict()
        for kind, dish in tableToday.items():
            if not any(f in kind.lower() for f in filters):
                continue
            menu[kind] = dish
    else:
        menu = OrderedDict(tableToday)
    return menu


if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description="Menü der Mensa Koblenz anzeigen")
    parser.add_argument("-s", "--short", action="store_true", help="Ausgabe in Kurzform")
    parser.add_argument("-m", "--maindish", action="store_true",
                        help="Nur Hauptgericht (ohne Suppe, Salat, Dessert) anzeigen")
    parser.add_argument("offset", nargs="?", help="Wochentag ändern, z.B. '+2' (übermorgen), '-1' (gestern)")
    parser.add_argument("filter", nargs="*", help="Filter für Menü-Art (z.B. 'veg', '1', …)")    
    args = parser.parse_args()
    posargs = args.filter
    if args.offset:
        posargs += [args.offset]
    offset = 0
    for i, arg in enumerate(posargs):
        if arg[0] in "+-":
            offset = int(arg)
            del posargs[i]
            break
    menu = getMenu(filters=posargs, offset=offset)
    if args.maindish:
        for key, value in menu.items():
            words = value.split(" ")
            if "uppe" in words[0]:
                del words[0]
            for buzz in "Dessert", "Salat", "und":
                if words[-1] == buzz:
                    del words[-1]
            menu[key] = " ".join(words).strip("., ")
    if not args.short:
        maxNameLength = max(len(kind) for kind in menu)
        for kind, dish in menu.items():
            print(('{:' + str(maxNameLength+1) + 's}: {}').format(kind, dish))
    else:
        print("; ".join(menu.values()))
