#!/usr/bin/python
# coding: UTF-8
# Copyright: 2013 Michael Helmling
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3 as
# published by the Free Software Foundation
#
# mensakoblenz - Skript zur Textausgabe des aktuellen Tagesmenüs in der
# Mensa der Uni Koblenz.
 

from collections import OrderedDict
import datetime
import urllib.request
import sys

from bs4 import BeautifulSoup, SoupStrainer

speiseplanURL="http://www.studierendenwerk-koblenz.de/go/uni-campus-koblenz/essen/speiseplan"
tableClass="speiseplan kw kw-{:02d}" # Klasse der Speiseplan-Tabelle; Kalenderwoche als Platzhalter

def getHTML():
    """Komplette HTML-Seite abrufen."""
    with urllib.request.urlopen(speiseplanURL) as f:
        html = f.read().decode('utf-8')
    return html
    
def getTable(html, week):
    """Tabelle der angegebenen Woche als Liste von OrderedDicts parsen.
    
    Gibt eine Liste zurück, die den numerischen Wochentag (0 = Montag) auf ein geordnetes
    Dictionary abbildet. In letzterem wird die Art des Menüs ("Abendmensa", "Menü 1", etc.)
    auf das Menü des entsprechenden Wochentags abgebildet.
    """
    onlyCurrentWeek = SoupStrainer(class_=tableClass.format(week))
    soup = BeautifulSoup(html, parse_only=onlyCurrentWeek).contents[0]
    headers = [head.text for head in soup.contents[0].contents[1:]] # erste Spalte auslassen (Datum)
    ans = []
    for row in soup.contents[1:]:
        cols = [ col.text.strip(". ") for col in row.contents[1:] ]
        dct = OrderedDict(zip(headers, cols))
        ans.append(dct)
    return ans
        
def currentWeekAndDay():
    """Gibt die aktuelle Kalenderwoche und den Wochentag als Tupel zurück"""
    today = datetime.date.today()
    return today.isocalendar()[1], today.weekday()

extraFilters = { "all" : "", "veggie" : "vegetarisch", "pasta" : "extra"}
"""Eine Liste von Ersetzungstexten für Kommandozeilenparameter."""

def todaysMenu(filters=None):
    """Das heutige Menü; falls *filter* gesetzt ist, nur Menüs der entsprechenden Art.
    
    Gefiltert werden alle Menüarten die den Filter (oder den entsprechenden Ersetzungstext aus
    *extraFilters* als Teiltext enthalten. Beispiele: "veg", "veggie", "abend", "pasta".
    """
    html = getHTML()
    week, day = currentWeekAndDay()
    table = getTable(html, week)
    tableToday = table[day]
    if filters is not None and len(filters) > 0:
        filters = [extraFilters[f.lower()] if f in extraFilters else f.lower() for f in filters]
        menu = OrderedDict()
        for kind, dish in tableToday.items():
            if not any(f in kind.lower() for f in filters):
                continue
            menu[kind] = dish
    return menu

if __name__ == "__main__":
    """Standardverhalten: Gib das heutige Menü aus; eventueller Filter wird aus Argument 1 gelesen."""
    import argparse
    parser = argparse.ArgumentParser(description="Menü der Mensa Koblenz anzeigen")
    parser.add_argument("-s", "--short", action="store_true", help="Ausgabe in Kurzform")
    parser.add_argument("-m", "--maindish", action="store_true",
                        help="Nur Hauptgericht (ohne Suppe, Salat, Dessert) anzeigen")
    parser.add_argument("filter", nargs="*", help="Menüsorten ausfiltern")
    args = parser.parse_args()
    menu = todaysMenu(args.filter)
    if args.maindish:
        for key, value in menu.items():
            words = value.split(" ")
            if "uppe" in words[0]:
                del words[0]
            for buzz in "Dessert", "Salat", "und":
                if words[-1] == buzz:
                    del words[-1]
            menu[key] = " ".join(words).strip("., ")
    if not args.short:
        maxNameLength = max(len(kind) for kind in menu)
        for kind, dish in menu.items():
            print(('{:' + str(maxNameLength) + 's}: {}').format(kind, dish))
    else:
        print("; ".join(menu.values()))
